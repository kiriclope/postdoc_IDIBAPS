import importlib, sys
from importlib import reload

import numpy as np
import matplotlib.pyplot as plt

import scipy.integrate as integrate
import scipy.special as special
from scipy.optimize import fsolve, root

import random as rand

import constants as gv
importlib.reload(sys.modules['constants'])

import mf_utils
from mf_utils import *
importlib.reload(sys.modules['mf_utils'])

def branch_kappa_0_eqs(x):
    
    u_0 = x[0]
    sigma_0 = abs(x[1])

    mean_eq = u_0/np.sqrt(gv.K) - ( gv.I0 + gv.J0 * mean_rate(u_0, sigma_0, 0 ) )  
    var_eq = sigma_0 - variance(u_0, sigma_0, 0)

    eqs = np.array([mean_eq, var_eq])
    return eqs.flatten()

def branch_kappa_pos_eqs(x):
    
    u = x[0]
    sigma_0 = abs(x[1])
    kappa = abs(x[2])
    
    mean_eq = u/np.sqrt(gv.K)  - ( gv.I0 + gv.J0 * mean_rate(u, sigma_0, kappa ) + gv.J1 * kappa/np.sqrt(gv.K) ) 
    var_eq = sigma_0 - variance(u, sigma_0, kappa) 
    # kappa_eq = kappa - np.sqrt( (u**2 / np.real(special.lambertw(u/gv.sigma_1))**2 - (1 + sigma_0) ) / gv.sigma_1 ) 
    kappa_eq = kappa - np.sqrt( abs(u**2 /2.0 / np.log(gv.sigma_1/u/np.sqrt(2*np.pi)) - (1 + sigma_0) ) / gv.sigma_1 ) 
    # kappa_eq = np.sqrt(1+sigma_0+gv.sigma_1*kappa**2) / gv.sigma_1 - phi(u/np.sqrt(1+sigma_0+gv.sigma_1*kappa**2))
    
    eqs = np.array([mean_eq, var_eq, kappa_eq])
    return eqs.flatten()

def branch_kappa_neg_eqs(x):

    u = x[0]
    sigma_0 = abs(x[1])
    kappa = -abs(x[2])
    
    mean_eq = u/np.sqrt(gv.K)  - ( gv.I0 + gv.J0 * mean_rate(u, sigma_0, kappa ) + gv.J1 * kappa/np.sqrt(gv.K) )  
    var_eq = sigma_0 - variance(u, sigma_0, kappa)
    # kappa_eq = kappa + np.sqrt( (u**2 / np.real(special.lambertw(u/gv.sigma_1))**2 - (1 + sigma_0) ) / gv.sigma_1 ) 
    kappa_eq = kappa + np.sqrt( abs(u**2 /2.0 / np.log(gv.sigma_1/u/np.sqrt(2*np.pi)) - (1 + sigma_0) ) / gv.sigma_1 ) 
    # kappa_eq = np.sqrt(1+sigma_0+gv.sigma_1*kappa**2) - gv.sigma_1 * phi(u/np.sqrt(1+sigma_0+gv.sigma_1*kappa**2)) 
    eqs = np.array([mean_eq, var_eq, kappa_eq])
    return eqs.flatten()

def solve_mf(branch):
    print_globals()

    counter = 0
    if(branch==0):
        x0 = [rand.random()/2 for i in range(0,2)]
        u = x0[0]
        sigma_0 = x0[1]
        kappa = 0
        y = root(branch_kappa_0_eqs, x0, method='lm')
        
        while (any(t>=gv.TOL for t in branch_kappa_0_eqs(x0)) and counter<gv.MAX_ITER):
            x0 = [rand.random()/2 for i in range(0,2)]
            y = root(branch_kappa_0_eqs, x0, method='lm')

            u = y.x[0]
            sigma_0 = y.x[1]
            kappa = 0

            x0 = [u, sigma_0]
            print('iter ', counter, ' sol ', x0, ' error ', branch_kappa_0_eqs(x0))
            if any(t==True for t in np.isnan(x0)):
                x0 = [rand.random() for i in range(0,3)]            
            counter +=1
            
    if(branch==1):
        x0 = [rand.random() for i in range(0,3)]
        u = x0[0]
        sigma_0 = x0[1]
        kappa = x0[2]
        y = root(branch_kappa_pos_eqs, x0, method='lm')

        while (any(t>=gv.TOL for t in branch_kappa_pos_eqs(x0)) and counter<gv.MAX_ITER):
            x0 = [rand.random()/10 for i in range(0,3)]
            y = root(branch_kappa_pos_eqs, x0, method='lm')

            u = y.x[0]
            sigma_0 = y.x[1]
            kappa = y.x[2]

            x0 = [u, sigma_0, kappa]
            print('iter ', counter, ' sol ', x0, ' error ', branch_kappa_pos_eqs(x0))
            if any(t==True for t in np.isnan(x0)):
                x0 = [rand.random() for i in range(0,3)] 
            counter +=1


    if(branch==-1):
        x0 = [rand.random()/2 for i in range(0,3)]
        u = x0[0]
        sigma_0 = abs(x0[1])
        kappa = x0[2]
        y = root(branch_kappa_neg_eqs, x0, method='lm')
        
        while (any(t>=gv.TOL for t in branch_kappa_neg_eqs(x0)) and counter<gv.MAX_ITER):
            x0 = [rand.random() for i in range(0,3)]            
            y = root(branch_kappa_neg_eqs, x0, method='lm')

            u = y.x[0]
            sigma_0 = y.x[1]
            kappa = y.x[2]

            x0 = [u, sigma_0, kappa]
            print('iter ', counter, ' sol ', x0, ' error ', branch_kappa_neg_eqs(x0))
            if any(t==True for t in np.isnan(x0)):
                x0 = [rand.random() for i in range(0,3)]            
                
            counter +=1
    
    print('mean_rate %f' % mean_rate(u, sigma_0, kappa) ) 
    print('variance %f' % sigma_0)
    print('kappa %f' % kappa )
    return y
