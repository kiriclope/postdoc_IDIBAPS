#include "librairies.h"
#include "globals.h"
#include "net_utils.h"
#include "mat_utils.h"
#include "mean_field.h"

clock_t t1=clock();

int main(int argc , char** argv) {

  unsigned long int i,j,k ;
  int pre_pop, post_pop ; 
  double t_window=0., percentage=0. ;
  
  double (*transfert_func)(double) = NULL ;
  transfert_func = &Phi ; 
  // transfert_func = &threshold_linear ; 
  
  string dir ; 
  int n_pop ;
  unsigned long n_neurons ;
  double K ;
  get_args(argc , argv, dir, n_pop, n_neurons, K) ;
  
  double *ext_inputs, *J, *Tsyn ; 
  get_param(n_pop, dir, ext_inputs, J, Tsyn) ; 

  double *mf_rates ;
  mf_rates = new double [n_pop]() ;
  mean_field_rates(n_pop, ext_inputs, J, mf_rates) ;
    
  cout << "External Inputs : " ;
  for(int i=0;i<n_pop;i++) 
    cout << ext_inputs[i] << " ";
  cout << endl ;

  cout << "J : " ;
  for(int i=0;i<n_pop;i++) {
    for(int j=0;j<n_pop;j++) 
      cout << J[j+i*n_pop] << " ";
    cout << endl ;
  }

  cout << "Tsyn : " ;
  for(i=0;i<n_pop;i++) 
    for(j=0;j<n_pop;j++) 
      cout << Tsyn[j+i*n_pop] << " " ;
  cout << endl ;
  
  ///////////////////////////////////////////////////////////////////    
  // Random Connectivity, J
  ///////////////////////////////////////////////////////////////////    
  
  int *n_pre ;
  unsigned long *id_pre, *cum_id_pre ;
  
  string con_path ;
  con_path = "/homecentral/alexandre.mahrach/Connectivity/" ;
  con_path += to_string(n_pop) + "pop/N" + to_string(n_neurons) + "/K" + to_string((int)K) ;
  
  get_con_mat(con_path, n_neurons, n_pre, id_pre, cum_id_pre) ; 
  
  cout << n_pre[0] << " " << id_pre[0] << " " << cum_id_pre[0] << endl ;

  ///////////////////////////////////////////////////////////////////    
  // Structured Connectivity, \xi
  ///////////////////////////////////////////////////////////////////    
  
  ///////////////////////////////////////////////////////////////////    
  // Path
  ///////////////////////////////////////////////////////////////////    
  
  string path = "../" ;
  create_dir(dir, path, n_pop, n_neurons, K) ;

  n_neurons = n_neurons * 10000 ;
  
  int* n_per_pop ; 
  n_per_pop = new int [n_pop]() ; 

  for(i=0;i<n_pop;i++) 
    n_per_pop[i] = n_neurons/n_pop ; 
  
  int* cum_n_per_pop ; 
  cum_n_per_pop = new int [n_pop+1]() ; 

  cout <<"cum_n_per_pop=" << " " ; 
  for(i=0;i<n_pop+1;i++) { 
    for(j=0;j<i;j++) 
      cum_n_per_pop[i] += n_per_pop[j] ; 
    cout << cum_n_per_pop[i] << " " ;
  }
  cout << endl ;
 
  int *which_pop ; 
  which_pop = (int *) malloc( (unsigned long long) n_neurons * sizeof(int) ) ;

  for(i=0;i<n_pop;i++) 
    for(j=0; j<n_neurons; j++)
      if(j>=cum_n_per_pop[i] && j<cum_n_per_pop[i+1])
	which_pop[j] = i ; 
  
  ///////////////////////////////////////////////////////////////////     
  // Scaling 
  ///////////////////////////////////////////////////////////////////     

  for(i=0;i<n_pop;i++) {
    ext_inputs[i] = sqrt(K)*ext_inputs[i]*m0 ;
    for(j=0;j<n_pop;j++) 
      J[j+i*n_pop] = J[j+i*n_pop]/sqrt(K) ;
  }
  
  ///////////////////////////////////////////////////////////////////    
  // Variables 
  ///////////////////////////////////////////////////////////////////    

  double *rates ;
  rates = new double [n_neurons]() ; // instantaneous individual rates

  double *mean_rates ;
  mean_rates = new double [n_pop]() ; // population averaged rate also averaged over TIME_WINDOW
  
  double *filter_rates ;
  filter_rates = new double [n_neurons]() ; // temporal averaged over TIME_WINDOW

  // h^(ab)_i=h^b_i, inputs from presynaptic population b to postsynaptic neuron (i,a)
  double **inputs ;
  inputs = new double *[n_pop]() ;
  for(i=0;i<n_pop;i++) // presynaptic population b
    inputs[i] = new double [n_neurons]() ; 

  // htot_i = h^E_i + h^I_i, net input into neuron i
  double *net_inputs ;
  net_inputs = new double [n_neurons]() ;
  
  // S^(ab)_j=S^a_j, synapse from presynaptic neuron (j,b) to postsynaptic population a
  double **synapses ;
  synapses = new double *[n_pop]() ;
  for(i=0;i<n_pop;i++) //postsynaptic pop a
    synapses[i] = new double [n_neurons]() ;
      
  ///////////////////////////////////////////////////////////////////    
  // Files
  ///////////////////////////////////////////////////////////////////    

  string sMean = path + "/mean_rates.dat" ; 
  ofstream file_mean_rates(sMean.c_str(), ios::out | ios::ate);
  
  string sIdvRates = path + "/filter_rates.dat" ; 
  ofstream file_filter_rates(sIdvRates.c_str(), ios::out | ios::ate);

  ///////////////////////////////////////////////////////////////////    
  // Initial conditions
  ///////////////////////////////////////////////////////////////////    

  cout << "Initialization" << endl ;
  
  // default_random_engine gen  ;
  random_device rd;
  default_random_engine gen( rd() );
  uniform_real_distribution<double> unif(1,2) ;

  normal_distribution<double> gaussianI( 0, 1.0/8.0 ) ;
 
  for(i=0;i<n_neurons;i++) 
    net_inputs[j] = ext_inputs[which_pop[i]] ;
  
  for(i=0;i<n_pop;i++) 
    for(j=0;j<n_neurons;j++) {
      pre_pop = which_pop[j] ;
      synapses[i][j] = mf_rates[pre_pop] / (double) n_per_pop[pre_pop] + gaussianI(gen) ; 
      net_inputs[j] += synapses[i][j] ;
    }  

  for(i=0;i<n_neurons;i++) 
    rates[i] = transfert_func(net_inputs[i]) ;

  ///////////////////////////////////////////////////////////////////    
  // Dynamics of the network : Rate model
  ///////////////////////////////////////////////////////////////////    
	
  cout << "Main loop :" ;
  cout << " duration " << DURATION << " | DT " << DT ;
  cout << " | TIME_STEADY " << TIME_STEADY << " | TIME_WINDOW " << TIME_WINDOW << endl ;

  cout << "mean_field_rates: " ;
  for(i=0;i<n_pop;i++)
    cout << mf_rates[i] << " " ;
  cout << endl ;

  for (double t=0.; t<=DURATION; t+=DT) {

    percentage = t/DURATION ; 
    
    // cout << "updating synapses" << endl ;
    for(i=0;i<n_pop;i++) // postsynaptic pop
      for(j=0;j<n_neurons;j++) {
    	pre_pop = which_pop[j] ;
    	synapses[i][j] = (1.0-DT/Tsyn[i+pre_pop*n_pop])*synapses[i][j] + (DT/Tsyn[i+pre_pop*n_pop])*rates[j] ; 
      }
    
    // cout << "reseting synaptic inputs" << endl ;
    for(i=0;i<n_pop;i++) //postsynaptic pop
      for(j=0;j<n_neurons;j++) // presynaptic neuron
	inputs[i][j] = 0 ;
    
    // cout << "updating postsynaptic inputs" << endl ;// hai = sum_k Sak
    for(i=0;i<n_neurons;i++) { // postsynaptic pop
      post_pop = which_pop[i] ;
      for(j=cum_id_pre[i]; j<cum_id_pre[i]+n_pre[i]; j++) { // sum over presynaptic neurons of i
	pre_pop = which_pop[id_pre[j]] ; 
	if(id_pre[j]>=cum_n_per_pop[pre_pop] && id_pre[j]<cum_n_per_pop[pre_pop+1]) 
	  inputs[pre_pop][i] += J[pre_pop+post_pop*n_pop]*synapses[pre_pop][id_pre[j]] ;
      }
    }
        
    // cout << "reseting net inputs" << endl ;
    for(j=0;j<n_neurons;j++) 
      net_inputs[j] = ext_inputs[which_pop[j]] ;
    
    // updating net inputs
    for(i=0;i<n_pop;i++) 
      for(j=0;j<n_neurons;j++)
  	net_inputs[j] += inputs[i][j] ;

    // Updating Rates
    for(i=0;i<n_neurons;i++) {
      rates[i] = transfert_func(net_inputs[i]) ; 

      if(t>=TIME_STEADY) {
  	mean_rates[which_pop[i]] += rates[i] ; 
  	filter_rates[i] += rates[i] ; 
      }
    }
    
    // Writing to files        
    if(t_window>=TIME_WINDOW){      

      cout << int(percentage*100.0) << "% " ; 

      // mean rates
      cout << " t " << t-TIME_STEADY << " rates: ";
      for(i=0;i<n_pop;i++) 
      	cout << mean_rates[i]/TIME_WINDOW/(double)n_per_pop[i] << " " ;
      cout << "\r" ;
      cout.flush() ; 
      // cout << endl ;

      file_mean_rates << t-TIME_STEADY ;
      for(i=0;i<n_pop;i++) {
      	file_mean_rates << " " << mean_rates[i]/TIME_WINDOW/(double)n_per_pop[i] ; 
      	mean_rates[i] = 0 ; 
      }
      file_mean_rates << endl ; 

      // filtered rates over tw
      file_filter_rates << t-TIME_STEADY ;
      for(i=0;i<n_neurons;i++) {
  	file_filter_rates << " " << filter_rates[i]/TIME_WINDOW ;
  	filter_rates[i] = 0 ;
      }
      file_filter_rates << endl ;

      t_window=0. ;

    }//endif 

    // printProgress (percentage) ;
    //Defining time window 
    if(t>=TIME_STEADY)
      t_window += DT ;
    
  } //ENDMAINLOOP
  
    ///////////////////////////////////////////////////////////////////

  delete [] cum_id_pre ; 
  delete [] id_pre ; 
  delete [] n_pre ; 

  delete [] mean_rates ; 
  delete [] rates ; 
  delete [] filter_rates ; 

  delete [] synapses ; 
  delete [] inputs ; 
  delete [] net_inputs ; 
  
  delete [] ext_inputs ;
  delete [] J ;

  delete [] n_per_pop ;
  delete [] cum_n_per_pop ;
    
  file_mean_rates.close();
  file_filter_rates.close();

  cout << "done" << endl; 
  
  ///////////////////////////////////////////////////////////////////
  
  cout << "Simulation Done !" << endl;

  clock_t t2=clock();  
  int HOURS=0,MIN=0,SEC=0;
  string str_TIME = path + "/CPU_TIME.txt" ; 
  ofstream TIME(str_TIME.c_str(), ios::out | ios::ate);

  SEC = (t2-t1)/CLOCKS_PER_SEC ;
  HOURS = SEC/3600 ;
  MIN = SEC/60 ;
  SEC = SEC % 60 ;
  cout << "Elapsed Time = " << HOURS << "h " << MIN << "m " << SEC << "s" << endl;
  TIME << "Elapsed Time = " << HOURS << "h " << MIN << "m " << SEC << "s" << endl;
  TIME.close() ;
  return 0;

}
